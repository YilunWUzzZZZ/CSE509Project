#include "code_template.h"
string ptrace_template_p1 = 
"#include <sys/ptrace.h>\n"
"#include <sys/types.h>\n"
"#include <sys/wait.h>\n"
"#include <unistd.h>\n"
"#include <sys/user.h>\n"
"#include <sys/syscall.h>\n"
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <error.h>\n"
"#include <string.h>\n"
"#include <limits.h>\n"
"#include <stdlib.h>\n"
"#include <sys/mman.h>\n"
"#include <signal.h>\n"
"#include \"helpers.h\"\n"
"\n"
"#define MAX_STRING_LEN  40960\n"
"#define X32_SYSCALL_BIT 0x40000000U\n"
"#define X32_MASK 0xFFFFFFFFULL\n"
"int DEBUG = 0;\n"
"\n"
"#define debug_print(...) do { if (DEBUG) fprintf(stderr, __VA_ARGS__); } while (0)\n"
"\n"
"extern int setup_seccomp();\n"
"int deny = 1;\n"
"int reg_modified  = 0;\n"
"\n"
"\n"
"#define DENY() {deny = 1; goto out;}\n"
"#define ALLOW() {deny = 0; goto out;}\n"
"\n"
"\n"
"#define SET_ARG(idx, new_val) {arguments[idx] = new_val; reg_modified=1;}\n"
"#define GET_ARG(idx) (arguments[idx])\n"
"\n"
"\n"
"\n"
"char * ptrace_copy_out_mem(int child, void * tracee_ptr, int copy_size) {\n"
"    int n_words = copy_size / sizeof(void*);\n"
"    n_words = (n_words % sizeof(void*)) ? n_words + 1 : n_words;\n"
"    long * new_buf = (long*)malloc(n_words * sizeof(void*));\n"
"    for (int i=0; i<n_words; i++) {\n"
"        new_buf[i] = ptrace(PTRACE_PEEKDATA,\n"
"                            child, tracee_ptr,\n"
"                            NULL);\n"
"        tracee_ptr += sizeof(void*);\n"
"    }\n"
"    return (char*)new_buf;\n"
"}\n"
"\n"
"void ptrace_copy_back_mem(int child, void * tracee_ptr, void * tracer_ptr, int copy_size) {\n"
"    int n_words = copy_size / sizeof(void*);\n"
"    n_words = (n_words % sizeof(void*)) ? n_words + 1 : n_words;\n"
"    long * buf = (long*)tracer_ptr;\n"
"    for (int i=0; i<n_words; i++) {\n"
"        ptrace(PTRACE_POKEDATA,\n"
"                            child, tracee_ptr,\n"
"                            buf[i]);\n"
"        tracee_ptr += sizeof(void*);\n"
"    }\n"
"}\n"
"\n"
"char * ptrace_copy_out_string(int child, void * tracee_ptr) {\n"
"    char * tracee_addr = tracee_ptr;\n"
"    union {\n"
"        long val;\n"
"        char word[sizeof(void*)];\n"
"    } data;\n"
"    int cnt = 0;\n"
"    char * str = malloc(MAX_STRING_LEN+1);\n"
"    int string_end = 0;\n"
"    while (cnt < MAX_STRING_LEN) {\n"
"        data.val = ptrace(PTRACE_PEEKDATA,\n"
"                            child, tracee_addr,\n"
"                            NULL);\n"
"        memcpy(&str[cnt], data.word, sizeof(void*));\n"
"\n"
"        for (int i=0; i < sizeof(void*); i++) {\n"
"            cnt++;\n"
"            tracee_addr++;\n"
"            if (!data.word[i]) {\n"
"                string_end = 1;\n"
"                break;\n"
"            } \n"
"        }\n"
"\n"
"        if (string_end) {\n"
"            break;\n"
"        }\n"
"    }\n"
"    str[MAX_STRING_LEN] = 0;\n"
"    return str;\n"
"}\n"
"\n"
"void ptrace_copy_back_string(int child, char * tracer_ptr, void * tracee_ptr) {\n"
"    int str_len = strlen(tracer_ptr) + 1;\n"
"    int n_words = str_len / sizeof(void*);\n"
"    int cnt = 0;\n"
"    int remain = str_len % sizeof(void*);\n"
"    long * new_ptr = (long*)tracer_ptr;\n"
"    long * target_ptr = (long*)tracee_ptr;\n"
"\n"
"    while(cnt < n_words) {\n"
"        ptrace(PTRACE_POKEDATA, child,\n"
"               target_ptr, *new_ptr);\n"
"\n"
"        cnt += 1;\n"
"        new_ptr += 1;\n"
"        target_ptr += 1;\n"
"    }\n"
"    \n"
"    if(remain) {\n"
"        long data = 0;\n"
"        memcpy((void*)&data, (void*)new_ptr, remain);\n"
"        ptrace(PTRACE_POKEDATA, child,\n"
"               target_ptr, data);\n"
"    }\n"
"    free(tracer_ptr);\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"int main(int argc, char ** argv)\n"
"{   \n"
;
string ptrace_template_p2 = 
"    pid_t child;\n"
"    pid_t direct_child;\n"
"    int first_fork = 1;\n"
"    long params[3];\n"
"    int status;\n"
"    int syscall_code = -1;\n"
"    int terminated = 0;\n"
"\n"
"\n"
"    struct user_regs_struct regs;\n"
"    if (argc < 2) {\n"
"        printf(\"usage: sandbox [prisoner_app] ... \\n\");\n"
"        exit(-1);\n"
"    }\n"
"    char * bin = argv[1];\n"
"    char *  args[argc];\n"
"\n"
"    for (int i=0; i<argc-1; i++) {\n"
"        args[i] = argv[i+1];\n"
"    }\n"
"    args[argc-1] = NULL;\n"
"\n"
"    child = fork();\n"
"    if(child == 0) {\n"
"        ptrace(PTRACE_TRACEME, 0, NULL, NULL);\n"
"        setup_seccomp();\n"
"        if (execvp(bin, args)) {\n"
"            perror(\"execvp:\");\n"
"        }\n"
"    } else {\n"
"        direct_child = child;\n"
"        while(1) {\n"
"            child = wait(&status);\n"
"            \n"
"            if( child == -1 || (WIFEXITED(status) && child == direct_child))\n"
"                break;\n"
"            \n"
"            if (first_fork && child == direct_child && WIFSTOPPED(status)) {\n"
"                first_fork = 0;\n"
"                // auto-attach the whole process tree\n"
"                printf(\"Setting up ptrace\\n\");\n"
"                ptrace(PTRACE_SETOPTIONS, child, NULL,  PTRACE_O_EXITKILL| PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORK | \n"
"                PTRACE_O_TRACECLONE | PTRACE_O_TRACESECCOMP);\n"
"                ptrace(PTRACE_CONT, child, NULL, NULL);\n"
"                continue;\n"
"            }\n"
"\n"
"            if ( !(status>>8 == (SIGTRAP | (PTRACE_EVENT_SECCOMP<<8)))) {\n"
"              ptrace(PTRACE_CONT, child, NULL, NULL);\n"
"              continue;\n"
"            } else {\n"
"            //   printf(\"Received request from seccomp\\n\");\n"
"            }\n"
"\n"
"            unsigned long seccomp_ret_data;\n"
"            ptrace(PTRACE_GETREGS, child, NULL, &regs);\n"
"            // Get event message to locate the exact handling logic\n"
"            ptrace(PTRACE_GETEVENTMSG, child, NULL, &seccomp_ret_data);\n"
"            unsigned long long arguments[6];\n"
"            reg_modified=0;\n"
"            if (regs.orig_rax & X32_SYSCALL_BIT) {\n"
"                arguments[0] = regs.rbx & X32_MASK;\n"
"                arguments[1] = regs.rcx & X32_MASK;\n"
"                arguments[2] = regs.rdx & X32_MASK;\n"
"                arguments[3] = regs.rsi & X32_MASK;\n"
"                arguments[4] = regs.rdi & X32_MASK;\n"
"                arguments[5] = regs.rbp & X32_MASK;\n"
"            } else {\n"
"                arguments[0] = regs.rdi;\n"
"                arguments[1] = regs.rsi;\n"
"                arguments[2] = regs.rdx;\n"
"                arguments[3] = regs.r10;\n"
"                arguments[4] = regs.r8;\n"
"                arguments[5] = regs.r9;\n"
"            }\n"
"            goto *start_table[seccomp_ret_data];\n"
;
string ptrace_template_p3 = 
"   \n"
"out:     \n"
"            if (deny) {\n"
"              printf(\"Killing offending process %d\\n\", child);\n"
"              kill(child, SIGKILL);\n"
"              continue;\n"
"            } else {\n"
"              if (reg_modified) {\n"
"                if (regs.orig_rax & X32_SYSCALL_BIT) {\n"
"                    regs.rbx = arguments[0];\n"
"                    regs.rcx = arguments[1];\n"
"                    regs.rdx = arguments[2];\n"
"                    regs.rsi = arguments[3];\n"
"                    regs.rdi = arguments[4];\n"
"                    regs.rbp = arguments[5];\n"
"                } else {\n"
"                    regs.rdi = arguments[0];\n"
"                    regs.rsi = arguments[1];\n"
"                    regs.rdx = arguments[2];\n"
"                    regs.r10 = arguments[3];\n"
"                    regs.r8 = arguments[4];\n"
"                    regs.r9 = arguments[5];\n"
"                }\n"
"                ptrace(PTRACE_SETREGS, child, NULL, &regs);\n"
"              }\n"
"              ptrace(PTRACE_CONT, child,\n"
"                      NULL, NULL);\n"
"            }\n"
"       }\n"
"   }\n"
"   return 0;\n"
"}\n"
;
string seccomp_template_p1 = 
"#include <errno.h>\n"
"#include <stddef.h>\n"
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <unistd.h>\n"
"#include <linux/audit.h>\n"
"#include <linux/filter.h>\n"
"#include <linux/seccomp.h>\n"
"#include <sys/prctl.h>\n"
"#include <sys/syscall.h>\n"
"\n"
"int seccomp(unsigned int operation, unsigned int flags,void *args) {\n"
"    return syscall(SYS_seccomp, operation, flags, args);\n"
"}\n"
"\n"
"#define X32_SYSCALL_BIT 0x40000000U\n"
"#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))\n"
"\n"
"static int\n"
"install_filter()\n"
"{\n"
"    unsigned int upper_nr_limit = 0xffffffff;\n"
"\n"
"    /* Assume that AUDIT_ARCH_X86_64 means the normal x86-64 ABI\n"
"      (in the x32 ABI, all system calls have bit 30 set in the\n"
"      'nr' field, meaning the numbers are >= X32_SYSCALL_BIT). */\n"
"    unsigned int t_arch = AUDIT_ARCH_X86_64;\n"
"    upper_nr_limit = X32_SYSCALL_BIT - 1;\n"
"\n"
"    struct sock_filter filter[] = {\n"
;
string seccomp_template_p2 = 
"    };\n"
"\n"
"    struct sock_fprog prog = {\n"
"        .len = ARRAY_SIZE(filter),\n"
"        .filter = filter,\n"
"    };\n"
"\n"
"    if (seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog)) {\n"
"        perror(\"seccomp\");\n"
"        return 1;\n"
"    }\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"int\n"
"setup_seccomp()\n"
"{\n"
"\n"
"    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n"
"        perror(\"prctl\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"\n"
"    if (install_filter())\n"
"        exit(EXIT_FAILURE);\n"
"    return 0;\n"
"\n"
"}\n"
;
